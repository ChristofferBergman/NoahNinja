<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Ninja Gesture Game</title>
<style>
  body { margin: 0; background: #111; overflow: hidden; font-family: sans-serif; }
  canvas { display: block; background: linear-gradient(to top, #333, #555); cursor: crosshair; }
  #powerupMenu {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    background: rgba(0,0,0,0.9); color: #fff; padding: 30px; border-radius: 15px; text-align: center;
    display: none; z-index: 100;
  }
  #powerupMenu button {
    margin: 10px; padding: 10px 20px; font-size: 16px; border-radius: 8px;
    cursor: pointer; background: #222; color: #fff; border: none;
  }
  #powerupMenu button:hover { background: #444; }
  #xpDisplay { position: absolute; top: 10px; left: 10px; color: #ff0; font-size: 18px; }
  #throwsDisplay { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 18px; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<div id="xpDisplay">XP: 0/5</div>
<div id="throwsDisplay">Throws: 3/3</div>
<div id="powerupMenu">
  <h2>Choose a Power-up!</h2>
  <button id="powerThrow">Increase Throw Power</button>
  <button id="powerAttack">Longer Attack Mode</button>
  <button id="powerSlowmo">Stronger Slow-mo</button>
  <button id="powerExtraThrows">Extra Throws</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
let width = window.innerWidth;
let height = window.innerHeight;
canvas.width = width;
canvas.height = height;

const baseGravity = 0.8;
let gameOver = false;
let slowMotion = 1;
let attackTimeout = null;
let attackUnlimited = false;

const hillAmplitude = 80;
const hillFrequency = 0.002;
function getGroundY(x) { return height * 0.8 + Math.sin(x * hillFrequency) * hillAmplitude; }

const ninja = {
  x: width*0.2, y: getGroundY(width*0.2)-20, vx:0, vy:0, size:40,
  color:"#fff", attacking:false, dead:false, throwsLeft:3, maxThrows:3
};

let enemies = [];
function spawnEnemy() {
  const fromLeft = Math.random() < 0.5;
  const xpNeeded = xpToLevel;
  let type = "normal";
  if(xpNeeded>=40 && Math.random()<0.1) type="purple";
  else if(xpNeeded>=20 && Math.random()<0.2) type="big";
  enemies.push({
    x: fromLeft?-50:width+50,
    y: getGroundY(fromLeft?0:width)-20,
    size: type==="big"?60:40,
    color: type==="purple"?"#a0f":"#0f0",
    dead:false,
    dir: fromLeft?1:-1,
    speed: type==="purple"?3+Math.random()*1.5:2+Math.random()*1.5,
    type:type,
    hp: type==="big"?2:type==="purple"?4:1,
    cooldown:0
  });
}

let gesture={active:false, startX:0, startY:0, currentX:0, currentY:0};

// XP & Power-ups
let xp = 0;
let xpToLevel = 5;
let maxThrowPower = 30;
let attackDuration = 500;
let slowmoStrength = 0.2;

const xpDisplay = document.getElementById("xpDisplay");
const throwsDisplay = document.getElementById("throwsDisplay");
const powerupMenu = document.getElementById("powerupMenu");
const powerThrowBtn = document.getElementById("powerThrow");
const powerAttackBtn = document.getElementById("powerAttack");
const powerSlowmoBtn = document.getElementById("powerSlowmo");
const powerExtraThrowsBtn = document.getElementById("powerExtraThrows");

function showPowerupMenu() { powerupMenu.style.display="block"; slowMotion=0; }
function hidePowerupMenu() { powerupMenu.style.display="none"; slowMotion=1; xp=0; xpDisplay.textContent=`XP: ${xp}/${xpToLevel}`; }

powerThrowBtn.addEventListener("click", ()=>{ maxThrowPower+=15; hidePowerupMenu(); });
powerAttackBtn.addEventListener("click", ()=>{ attackDuration+=400; hidePowerupMenu(); });
powerSlowmoBtn.addEventListener("click", ()=>{ slowmoStrength *=0.5; hidePowerupMenu(); });
powerExtraThrowsBtn.addEventListener("click", ()=>{ ninja.maxThrows+=1; ninja.throwsLeft=ninja.maxThrows; hidePowerupMenu(); });

let xpPopups = [];

function drawGround(){
  ctx.beginPath();
  ctx.moveTo(0,getGroundY(0));
  for(let x=0;x<=width;x+=10) ctx.lineTo(x,getGroundY(x));
  ctx.lineTo(width,height);
  ctx.lineTo(0,height);
  ctx.closePath();
  ctx.fillStyle="#222"; ctx.fill();
}

function drawNinja(){
  ctx.save(); ctx.translate(ninja.x,ninja.y); ctx.strokeStyle=ninja.color; ctx.lineWidth=4; ctx.lineCap="round";
  ctx.beginPath(); ctx.arc(0,-ninja.size,8,0,Math.PI*2); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,-ninja.size+8); ctx.lineTo(0,0); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,-ninja.size/2); ctx.lineTo(-10,-ninja.size/4);
  ctx.moveTo(0,-ninja.size/2); ctx.lineTo(10,-ninja.size/4); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-10,15); ctx.moveTo(0,0); ctx.lineTo(10,15); ctx.stroke();
  ctx.strokeStyle="red"; ctx.beginPath(); ctx.moveTo(-6,-ninja.size-5); ctx.lineTo(6,-ninja.size-5); ctx.stroke();
  ctx.restore();
}

function drawEnemies() {
  for (let e of enemies) {
    ctx.font = `${e.size}px sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";

    // if dead, fade to gray and shrink slightly
    if (e.dead) {
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "#555";
      ctx.fillText("ðŸ’€", e.x, e.y);
      ctx.globalAlpha = 1.0;
    } else {
      ctx.fillStyle = "#0f0";
      ctx.fillText("ðŸ‘½", e.x, e.y);
    }
  }
}

function drawAimLine(){
  if(!gesture.active) return;
  ctx.strokeStyle="rgba(255,255,0,0.5)"; ctx.lineWidth=3;
  ctx.beginPath(); ctx.moveTo(gesture.startX,gesture.startY); ctx.lineTo(gesture.currentX,gesture.currentY); ctx.stroke();
  const dx=gesture.currentX-gesture.startX, dy=gesture.currentY-gesture.startY, dist=Math.sqrt(dx*dx+dy*dy);
  ctx.fillStyle="#ff0"; ctx.font="16px sans-serif";
  ctx.fillText(`Power: ${Math.round(dist)}`, gesture.startX+10, gesture.startY-10);
}

function drawGameOver(){
  ctx.fillStyle="rgba(0,0,0,0.6)"; ctx.fillRect(0,0,width,height);
  ctx.fillStyle="#fff"; ctx.font="48px sans-serif"; ctx.textAlign="center";
  ctx.fillText("ðŸ’€ Game Over ðŸ’€", width/2,height/2);
  ctx.font="24px sans-serif"; ctx.fillText("Reload to restart", width/2,height/2+50);
}

function updateNinja(dt){
  ninja.vy+=baseGravity*dt;
  ninja.x+=ninja.vx*dt; ninja.y+=ninja.vy*dt;
  const groundHere=getGroundY(ninja.x);
  let touchingGround = false;
  if(ninja.y>=groundHere-20){
    ninja.y=groundHere-20; ninja.vy=0; ninja.vx*=0.98;
    ninja.throwsLeft=ninja.maxThrows;
    touchingGround=true;
  } else ninja.vx*=0.977;
  if(ninja.x<20) ninja.x=20;
  if(ninja.x>width-20) ninja.x=width-20;
  if(ninja.y-ninja.size<0){ ninja.y=ninja.size; ninja.vy=0; }
  ninja.y=Math.min(ninja.y,groundHere-20);

  // Unlimited attack only when falling with 0 throws
  attackUnlimited = (!touchingGround && ninja.throwsLeft<=0);

  // Exit attack mode normally if not unlimited
  if(!attackUnlimited && ninja.attacking && !gesture.active && attackTimeout===null){
    ninja.attacking=false;
    ninja.color="#fff";
  }

  // Update slow motion
  slowMotion = ninja.attacking ? 1 : slowmoStrength;

  // Update throws display
  throwsDisplay.textContent = `Throws: ${ninja.throwsLeft}/${ninja.maxThrows}`;
}

function updateEnemies(dt){
  for(let e of enemies){
    if(e.type==="purple"){
      let dx = ninja.x - e.x;
      let dy = ninja.y - e.y;
      e.x += dx*0.02*dt;
      e.y += dy*0.02*dt;
    } else e.x += e.speed*e.dir*dt;
    if((e.dir===1 && e.x>ninja.x) || (e.dir===-1 && e.x<ninja.x)) e.dir*=-1;
    if(e.type!=="purple") e.y = getGroundY(e.x)-20;
    if(e.cooldown>0) e.cooldown-=dt;
  }

  // XP detection
  enemies.forEach(e=>{
    const dx = ninja.x - e.x, dy = ninja.y - e.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<30 && ninja.attacking && !e.dead && e.cooldown<=0){
      e.hp--;
      e.cooldown = 10;
      if(e.hp<=0){
        e.dead=true;
        let gainedXP = e.type==="purple"?4:1;
        xp+=gainedXP;
        xpDisplay.textContent=`XP: ${xp}/${xpToLevel}`;
        xpPopups.push({x:e.x,y:e.y,text:`+${gainedXP}`,alpha:1});
        if(xp>=xpToLevel) showPowerupMenu();
      } else if(e.type==="big") e.color="#0f0"; // light green
    }
  });

  enemies = enemies.filter(e=>!e.dead && e.x>-100 && e.x<width+100);
}

function detectCollisions(){
  for(let e of enemies){
    const dx=ninja.x-e.x, dy=ninja.y-e.y, dist=Math.sqrt(dx*dx+dy*dy);
    if(dist<30 && !ninja.attacking){ ninja.dead=true; gameOver=true; }
  }
}

canvas.addEventListener("mousedown", e => { gesture.active=true; gesture.startX=e.clientX; gesture.startY=e.clientY; gesture.currentX=e.clientX; gesture.currentY=e.clientY; });
canvas.addEventListener("mousemove", e => { if(!gesture.active) return; gesture.currentX=e.clientX; gesture.currentY=e.clientY; });
canvas.addEventListener("mouseup", e => { if(gameOver) return; gesture.active=false; gesture.endX=e.clientX; gesture.endY=e.clientY; handleGesture(); });

// Mobile support
canvas.addEventListener("touchstart", e => { e.preventDefault(); gesture.active=true; gesture.startX=e.touches[0].clientX; gesture.startY=e.touches[0].clientY; gesture.currentX=e.touches[0].clientX; gesture.currentY=e.touches[0].clientY; });
canvas.addEventListener("touchmove", e => { e.preventDefault(); if(!gesture.active) return; gesture.currentX=e.touches[0].clientX; gesture.currentY=e.touches[0].clientY; });
canvas.addEventListener("touchend", e => { e.preventDefault(); if(gameOver) return; gesture.active=false; gesture.endX=gesture.currentX; gesture.endY=gesture.currentY; handleGesture(); });

function handleGesture(){
  const dx=gesture.endX-gesture.startX, dy=gesture.endY-gesture.startY, dist=Math.sqrt(dx*dx+dy*dy);
  if(dist<5 || ninja.throwsLeft<=0) return;
  const power=Math.min(dist/5,maxThrowPower);
  const angle=Math.atan2(dy,dx);
  ninja.vx=Math.cos(angle)*power;
  ninja.vy=Math.sin(angle)*power;
  ninja.throwsLeft--;

  // Attack mode logic
  if(!attackUnlimited){
    if(!ninja.attacking){
      ninja.attacking=true;
      ninja.color="#ff0";
      if(attackTimeout) clearTimeout(attackTimeout);
      attackTimeout=setTimeout(()=>{
        ninja.attacking=false;
        ninja.color="#fff";
        attackTimeout=null;
      },attackDuration);
    } else {
      if(attackTimeout){ clearTimeout(attackTimeout); attackTimeout=setTimeout(()=>{ ninja.attacking=false; ninja.color="#fff"; attackTimeout=null; },attackDuration); }
    }
  } else {
    ninja.attacking=true;
    ninja.color="#ff0";
    if(attackTimeout){ clearTimeout(attackTimeout); attackTimeout=null; }
  }
}

let lastTime=performance.now();
function loop(currentTime){
  const deltaTime=(currentTime-lastTime)/16.666;
  lastTime=currentTime;
  const dt=deltaTime*slowMotion;

  ctx.clearRect(0,0,width,height);
  drawGround(); drawEnemies(); drawNinja(); drawAimLine();

  // draw XP popups
  xpPopups.forEach(p=>{
    ctx.fillStyle=`rgba(255,255,0,${p.alpha})`;
    ctx.font="16px sans-serif";
    ctx.fillText(p.text,p.x,p.y);
    p.y-=0.5; p.alpha-=0.02;
  });
  xpPopups = xpPopups.filter(p=>p.alpha>0);

  if(!gameOver){ updateNinja(dt); updateEnemies(dt); detectCollisions(); }
  else drawGameOver();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function randomSpawnLoop(){
  if(gameOver) return;
  if(enemies.length<Math.min(3+Math.floor(xpToLevel/5),30)) spawnEnemy();
  setTimeout(randomSpawnLoop,1000+Math.random()*2000);
}
randomSpawnLoop();

window.addEventListener("resize", ()=>{
  width=window.innerWidth; height=window.innerHeight;
  canvas.width=width; canvas.height=height;
});
</script>
</body>
</html>
